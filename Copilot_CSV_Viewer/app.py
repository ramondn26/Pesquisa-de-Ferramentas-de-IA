"""
CSV Viewer - Aplicativo Streamlit para Visualiza√ß√£o e An√°lise de Dados CSV

Este m√≥dulo implementa uma aplica√ß√£o web usando Streamlit que permite aos usu√°rios:
- Fazer upload de arquivos CSV
- Visualizar e filtrar dados em tabelas interativas
- Gerar estat√≠sticas descritivas para colunas num√©ricas
- Criar gr√°ficos b√°sicos (barras e linhas)
- Buscar texto nos dados
- Controlar a exibi√ß√£o de linhas

Depend√™ncias:
    - streamlit: Interface web
    - pandas: Manipula√ß√£o e an√°lise de dados
    - utils: Fun√ß√µes utilit√°rias para processamento de dados

Autor: Desenvolvido como ferramenta de an√°lise de dados CSV
Data: 2025
"""

import streamlit as st
import pandas as pd
import logging
import time
from utils import (
    load_csv_data,
    filter_dataframe_by_text,
    get_numeric_columns,
    calculate_numeric_statistics,
    get_dataset_info,
    get_column_details,
    prepare_chart_data,
    validate_chart_requirements
)

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def process_uploaded_file(uploaded_file):
    """
    Processa o arquivo CSV carregado pelo usu√°rio.
    
    Carrega o arquivo CSV em um DataFrame do pandas, armazena no estado da sess√£o
    e exibe mensagens de confirma√ß√£o com informa√ß√µes b√°sicas do dataset.
    
    Args:
        uploaded_file: Arquivo carregado pelo Streamlit file_uploader
        
    Raises:
        Exception: Captura erros de leitura do arquivo CSV (formato inv√°lido, 
                  codifica√ß√£o, etc.) e exibe mensagem de erro ao usu√°rio.
    """
    start_time = time.time()
    logger.info(f"Iniciando upload de arquivo: {uploaded_file.name}")
    
    # Carrega o CSV usando fun√ß√£o utilit√°ria
    df = load_csv_data(uploaded_file)
    
    # Salva no estado da sess√£o
    st.session_state['dataframe'] = df
    st.session_state['filename'] = uploaded_file.name
    
    upload_duration = time.time() - start_time
    logger.info(f"Upload conclu√≠do: {uploaded_file.name} - {df.shape[0]} linhas, {df.shape[1]} colunas - Dura√ß√£o: {upload_duration:.3f}s")
    
    # Mensagem de confirma√ß√£o
    st.success(f"‚úÖ Arquivo '{uploaded_file.name}' carregado com sucesso!")
    st.info(f"üìà Dados: {df.shape[0]} linhas e {df.shape[1]} colunas")
    
    # Preview dos dados
    st.subheader("Preview dos Dados")
    st.dataframe(df.head(10))

def show_instructions():
    """
    Exibe instru√ß√µes de uso quando nenhum arquivo foi carregado.
    
    Mostra um guia passo-a-passo para o usu√°rio e limpa o estado da sess√£o
    de dados anteriores para evitar inconsist√™ncias.
    """
    # Instru√ß√µes quando n√£o h√° arquivo
    st.info("üëÜ **Instru√ß√µes:**")
    st.markdown("""
    1. Clique no bot√£o acima para fazer upload de um arquivo CSV
    2. O arquivo ser√° carregado automaticamente
    3. Voc√™ ver√° um preview dos dados ap√≥s o upload
    4. Formatos suportados: `.csv`
    """)
    
    # Limpa o estado da sess√£o se n√£o h√° arquivo
    if 'dataframe' in st.session_state:
        del st.session_state['dataframe']
    if 'filename' in st.session_state:
        del st.session_state['filename']

def show_search_feedback(search_text, filtered_df):
    """
    Exibe feedback sobre os resultados da busca por texto.
    
    Args:
        search_text: Texto buscado pelo usu√°rio
        filtered_df: DataFrame filtrado pelos resultados
    """
    if len(filtered_df) == 0:
        st.warning(f"‚ö†Ô∏è Nenhum resultado encontrado para '{search_text}'")
    else:
        st.info(f"üîç Encontrados {len(filtered_df)} registros para '{search_text}'")

def show_numeric_statistics(df):
    """
    Gera e exibe estat√≠sticas descritivas para colunas num√©ricas do dataset.
    
    Args:
        df: DataFrame com os dados para an√°lise
    """
    st.subheader("üî¢ Estat√≠sticas das Colunas Num√©ricas")
    
    # Calcular estat√≠sticas usando fun√ß√£o utilit√°ria
    stats_result = calculate_numeric_statistics(df)
    stats_df = stats_result['stats_df']
    summary = stats_result['summary']
    
    # Exibir tabela de estat√≠sticas
    st.dataframe(stats_df, use_container_width=True)
    
    # M√©tricas principais em colunas
    st.subheader("üìà Resumo Geral das Colunas Num√©ricas")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric(
            "Total de Colunas Num√©ricas",
            summary['total_numeric_columns']
        )
    
    with col2:
        st.metric(
            "Total de Valores",
            f"{summary['total_values']:,}"
        )
    
    with col3:
        st.metric(
            "Soma Geral",
            f"{summary['total_sum']:,.2f}"
        )
    
    with col4:
        st.metric(
            "M√©dia Geral",
            f"{summary['overall_mean']:.2f}"
        )

def show_no_numeric_columns_warning():
    """
    Exibe aviso quando o dataset n√£o possui colunas num√©ricas.
    """
    st.warning("‚ö†Ô∏è **Nenhuma coluna num√©rica encontrada no dataset**")
    st.info("""
    üìù **Informa√ß√£o:** 
    - O dataset n√£o possui colunas com dados num√©ricos (int, float)
    - Estat√≠sticas num√©ricas n√£o podem ser calculadas
    - Verifique se os dados foram importados corretamente
    """)

def show_dataset_summary(df):
    """
    Exibe resumo geral do dataset.
    
    Args:
        df: DataFrame com os dados para an√°lise
    """
    dataset_info = get_dataset_info(df)
    basic_info = dataset_info['basic_info']
    type_distribution = dataset_info['type_distribution']
    
    col1, col2 = st.columns(2)
    
    with col1:
        # Informa√ß√µes b√°sicas
        st.write("**Informa√ß√µes B√°sicas:**")
        st.write(f"‚Ä¢ **Dimens√µes:** {basic_info['dimensions']}")
        st.write(f"‚Ä¢ **Mem√≥ria utilizada:** ~{basic_info['memory_usage_kb']} KB")
        st.write(f"‚Ä¢ **Valores √∫nicos totais:** {basic_info['unique_values_total']:,}")
        st.write(f"‚Ä¢ **Valores nulos totais:** {basic_info['null_values_total']:,}")
    
    with col2:
        # Tipos de dados
        st.write("**Distribui√ß√£o por Tipos:**")
        for dtype, count in type_distribution.items():
            st.write(f"‚Ä¢ **{dtype}:** {count} colunas")

def generate_chart(df, chart_type, x_column, y_columns):
    """
    Processa e gera gr√°fico baseado nas sele√ß√µes do usu√°rio.
    
    Args:
        df: DataFrame com os dados
        chart_type: Tipo de gr√°fico ("Barras" ou "Linha")
        x_column: Nome da coluna para eixo X
        y_columns: Lista de colunas para eixo Y
    """
    start_time = time.time()
    logger.info(f"Iniciando gera√ß√£o de gr√°fico: tipo={chart_type}, x={x_column}, y={y_columns}")
    
    # Preparar dados usando fun√ß√£o utilit√°ria
    chart_result = prepare_chart_data(df, x_column, y_columns)
    chart_df = chart_result['chart_df']
    is_date = chart_result['is_date']
    y_stats = chart_result['stats']
    
    if len(chart_df) == 0:
        logger.warning("Gr√°fico n√£o p√¥de ser gerado: dados v√°lidos insuficientes")
        st.warning("‚ö†Ô∏è N√£o h√° dados v√°lidos para gerar o gr√°fico")
        return
    
    # Informar sobre detec√ß√£o de data
    if is_date:
        st.info("üìÖ Detectada coluna de data - dados ordenados cronologicamente")
    
    # Mostrar informa√ß√µes do gr√°fico
    st.info(f"üìä Exibindo {len(chart_df)} pontos de dados")
    
    # Preparar DataFrame para o gr√°fico (definir X como √≠ndice)
    chart_df_indexed = chart_df.set_index(x_column)
    
    # Gerar o gr√°fico baseado no tipo selecionado
    if chart_type == "Barras":
        st.bar_chart(
            chart_df_indexed[y_columns],
            height=400
        )
    else:  # Linha
        st.line_chart(
            chart_df_indexed[y_columns],
            height=400
        )
    
    # Mostrar resumo dos dados do gr√°fico
    with st.expander("üìã Dados do Gr√°fico"):
        st.dataframe(chart_df, use_container_width=True)
        
        # Estat√≠sticas r√°pidas das colunas Y usando dados pr√©-calculados
        st.write("**Estat√≠sticas das Colunas Y:**")
        for col in y_columns:
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric(f"{col} - M√≠nimo", f"{y_stats[col]['min']:.2f}")
            with col2:
                st.metric(f"{col} - M√°ximo", f"{y_stats[col]['max']:.2f}")
            with col3:
                st.metric(f"{col} - M√©dia", f"{y_stats[col]['mean']:.2f}")
    
    chart_duration = time.time() - start_time
    logger.info(f"Gr√°fico gerado com sucesso: {len(chart_df)} pontos de dados - Dura√ß√£o: {chart_duration:.3f}s")

def show_chart_section(df, numeric_columns):
    """
    Interface para configura√ß√£o e gera√ß√£o de gr√°ficos b√°sicos.
    
    Args:
        df: DataFrame com os dados
        numeric_columns: Colunas num√©ricas dispon√≠veis
    """
    st.subheader("üé® Configura√ß√£o do Gr√°fico")
    
    col1, col2, col3 = st.columns([1, 1, 2])
    
    with col1:
        # Sele√ß√£o do tipo de gr√°fico
        chart_type = st.selectbox(
            "Tipo de Gr√°fico:",
            ["Barras", "Linha"],
            help="Escolha o tipo de visualiza√ß√£o"
        )
    
    with col2:
        # Sele√ß√£o da coluna X
        x_column = st.selectbox(
            "Eixo X:",
            df.columns.tolist(),
            help="Coluna para o eixo horizontal"
        )
    
    with col3:
        # Sele√ß√£o das colunas Y (num√©ricas)
        y_columns = st.multiselect(
            "Eixo Y (Colunas Num√©ricas):",
            numeric_columns.tolist(),
            default=[numeric_columns[0]] if len(numeric_columns) > 0 else [],
            help="Selecione uma ou mais colunas num√©ricas para o eixo Y"
        )
    
    # Gerar gr√°fico se as sele√ß√µes est√£o v√°lidas
    if y_columns and x_column:
        try:
            generate_chart(df, chart_type, x_column, y_columns)
        except Exception as e:
            st.error(f"‚ùå Erro ao gerar gr√°fico: {str(e)}")
            st.info("üí° Dica: Verifique se as colunas selecionadas cont√™m dados v√°lidos")
    
    elif not y_columns and len(numeric_columns) > 0:
        st.info("üëÜ Selecione pelo menos uma coluna num√©rica para o eixo Y")

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="CSV Viewer",
    page_icon="üìä",
    layout="wide"
)

# T√≠tulo do app
st.title("üìä CSV Viewer")

# Se√ß√£o de upload
st.header("Upload de Arquivo CSV")

# Widget de upload
uploaded_file = st.file_uploader(
    "Escolha um arquivo CSV",
    type=['csv'],
    help="Selecione um arquivo CSV para visualizar"
)

# Processamento do arquivo
if uploaded_file is not None:
    try:
        process_uploaded_file(uploaded_file)
    except Exception as e:
        st.error(f"‚ùå Erro ao carregar o arquivo: {str(e)}")
else:
    show_instructions()

# Se√ß√£o de visualiza√ß√£o completa (s√≥ aparece se h√° dados carregados)
if 'dataframe' in st.session_state and 'filename' in st.session_state:
    st.header("üìã Visualiza√ß√£o Completa dos Dados")
    
    df = st.session_state['dataframe']
    
    # Informa√ß√µes do dataset
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Total de Linhas", df.shape[0])
    with col2:
        st.metric("Total de Colunas", df.shape[1])
    with col3:
        st.metric("Arquivo", st.session_state['filename'])
    
    # Controles de filtro e visualiza√ß√£o
    st.subheader("üîç Controles de Visualiza√ß√£o")
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        # Busca por texto
        search_text = st.text_input(
            "Buscar texto nos dados:",
            placeholder="Digite um termo para buscar...",
            help="A busca ser√° feita em todas as colunas (texto)"
        )
    
    with col2:
        # Controle de quantidade de linhas
        max_rows = st.number_input(
            "M√°ximo de linhas:",
            min_value=10,
            max_value=len(df),
            value=min(100, len(df)),
            step=10,
            help="Limite a quantidade de linhas exibidas"
        )
    
    # Aplicar filtros usando fun√ß√£o utilit√°ria
    start_time = time.time()
    filtered_df = filter_dataframe_by_text(df, search_text)
    filter_duration = time.time() - start_time
    
    if search_text:
        logger.info(f"Filtro aplicado: '{search_text}' - {len(filtered_df)} registros encontrados - Dura√ß√£o: {filter_duration:.3f}s")
    
    # Feedback sobre busca por texto
    if search_text:
        show_search_feedback(search_text, filtered_df)
    
    # Limitar quantidade de linhas
    display_df = filtered_df.head(max_rows)
    
    # Exibir informa√ß√µes do filtro
    if len(filtered_df) > max_rows:
        st.info(f"üìä Exibindo {max_rows} de {len(filtered_df)} linhas filtradas")
    
    # Tabela principal
    st.subheader("üìà Dados")
    st.dataframe(
        display_df,
        use_container_width=True,
        height=400
    )
    
    # Se√ß√£o de Estat√≠sticas
    st.header("üìä Estat√≠sticas dos Dados")
    
    # Obter colunas num√©ricas usando fun√ß√£o utilit√°ria
    numeric_columns = get_numeric_columns(df)
    
    if len(numeric_columns) > 0:
        show_numeric_statistics(df)
    else:
        show_no_numeric_columns_warning()
    
    # Resumo geral do dataset
    st.subheader("üìã Resumo Geral do Dataset")
    show_dataset_summary(df)
    
    # Se√ß√£o de Gr√°ficos
    st.header("üìà Gr√°ficos B√°sicos")
    
    # Validar requisitos para gr√°ficos usando fun√ß√£o utilit√°ria
    chart_valid, chart_message = validate_chart_requirements(df)
    
    if chart_valid:
        show_chart_section(df, numeric_columns)
    else:
        st.warning(f"‚ö†Ô∏è {chart_message}")
    
    # Informa√ß√µes adicionais usando fun√ß√£o utilit√°ria
    with st.expander("‚ÑπÔ∏è Informa√ß√µes das Colunas"):
        col_info = get_column_details(df)
        st.dataframe(col_info, use_container_width=True)